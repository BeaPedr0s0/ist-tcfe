%Analysis, part2

pkg load symbolic

printf ("\n\n-----------inicio programa-----------\n\n");

% Insertion of the resitors' values generated by datagen.py
R1 = 1.04111259479e+03;
R2 = 2.09945227782e+03;
R3 = 3.13109125645e+03;
R4 = 4.11947040212e+03;
R5 = 3.1155879392e+03;
R6 = 2.04799381798e+03; 
R7 = 1.02754401839e+03;

%R1 = 1.02591946196e+03; 
%R2 = 2.05138905661e+03;
%R3 = 3.09820234189e+03;
%R4 = 4.07126998238e+03; 
%R5 = 3.04248580013e+03; 
%R6 = 2.00249636786e+03; 
%R7 = 1.0123933318e+03; 
%Vs = 5.22225162486; 
%C = 1.02739994257e-06; 
%Kb = 7.04626963966e-03; 
%Kd = 8.17197962581e+03;



% Calculation of the inverse of the resistors. Useful to the Node Method
G1=1/R1;
G2=1/R2;
G3=1/R3;
G4=1/R4;
G5=1/R5;
G6=1/R6;
G7=1/R7;

% Insertion of the remaining values generated by datagen.py
Vs = 5.06871572779;
C = 1.04127523824e-06;
Kb = 7.28747116393e-03;
Kd = 8.11568444746e+03;

%The capacitor was replaced with a voltage Vx=V6-V8,
%where V6 and V8 are the voltages obtained when t<0
Vx=8.553593;

% Insertion of the matrices that will allow us to calculate the voltages of 
% each node

 
A =[1 0 0 0 0 0 0 0 0;
    0 0 0 1 0 0 0 0 0;
    -G1 G1+G2+G3 -G2 0 -G3 0 0 0 0;
    0 -Kb-G2 G2 0 Kb 0 0 0 0;   
    0 -G1 0 0 -G4 0 -G6 0 0;
    0 0 0 0 0 0 G6+G7 -G7 0;
    0 Kb 0 0 -Kb-G5 G5 0 0 -1;
    0 0 0 0 0 1 0 -1 0;
    0 -G3 0 0 G3+G4+G5 -G5 -G7 G7 1];

B = [0; 0; 0; 0; 0; 0; 0; Vx; 0];


% A*B=R <=>
R=inverse(A)*B;
%R=A\B;

%computation of the equivalent resistor (Req=Vx/(-Ix))
Req=(R(6)-R(8))/(R(9));

%time constant (tau=Req*C)
tau=Req*C;

% Creating a table in the mat folder with the voltages results
printf ("voltages_p2_TAB\n");
printf ("V1 = %e \n", R(1));
printf ("V2 = %e \n", R(2));
printf ("V3 = %e \n", R(3));
printf ("V4 = %e \n", R(4));
printf ("V5 = %e \n", R(5));
printf ("V6 = %e \n", R(6));
printf ("V7 = %e \n", R(7));
printf ("V8 = %e \n", R(8));
printf ( "voltages_p2_END\n");

printf ("\nnorten_current_p2_TAB\n");
printf ("Ix = %e \n", R(9));
printf ("norton_current_p2_END\n");

printf ("\nReq_tau_p2_TAB\n");
printf ("Req = %e \n", Req);
printf ("tau = %e \n", tau);
printf ("Req_tau_p2_END\n");


%----------------------natural solution-------------------------

printf ("\n\n-----------natural solution-----------\n\n");


%time axis: 0 to 20ms with 1us steps
t=0:1e-4:20e-3; %s


%Vx is the initial voltage

Vn=Vx*exp(-t/tau);


%Plot natural solution 
natural = figure ();
plot (t*1000, Vn, "g");
xlabel ("t[ms]");
ylabel ("Vnatural(t) [V]");
print (natural, "natural.eps", "-depsc");

%frequency [Hz]
f=1000;
w=2*pi*f;
Zc=-1/(j*w*C);


D =[1 0 0 0 0 0 0 0;
    -G1 G1+G2+G3 -G2 0 -G3 0 0 0;
    0 -Kb-G2 G2 0 Kb 0 0 0;
    0 0 0 1 0 0 0 0;
    0 -G3 0 -G4 G3+G5+G4 -G5 -G7 G7;
    0 Kb 0 0 -Kb-G5 G5+1/Zc 0 -1/Zc;
    0 0 0 -G6 0 0 G6+G7 -G7;
    0 0 0 Kd*G6 -1 0 -Kd*G6 1];

E=[exp(-j); 0; 0; 0; 0; 0; 0; 0];

% D*F=E <=>
F=D\E;


% Creating a table in the mat folder with the voltages results
printf ("voltages_p4_TAB\n");
printf ("V1 = %e \n", abs(F(1)));
printf ("V2 = %e \n", abs(F(2)));
printf ("V3 = %e \n", abs(F(3)));
printf ("V4 = %e \n", abs(F(4)));
printf ("V5 = %e \n", abs(F(5)));
printf ("V6 = %e \n", abs(F(6)));
printf ("V7 = %e \n", abs(F(7)));
printf ("V8 = %e \n", abs(F(8)));
printf ( "voltages_p4_END\n");

Vt = Vn + abs(F(6))*sin(w*t+acos(real(F(6))/abs(F(6))));

Vs = sin(w*t);

%time axis: -5 to 0ms with 1us steps
tneg=-5e-3:1e-5:0; %s

part4 = figure();
plot (t*1000, Vt, "r");
hold on;
plot (tneg*1000, Vx, "g");
plot (t*1000, Vs, "b")


xlabel ("t[ms]");
ylabel ("Vnatural(t)/Vs [V]");
print (part4, "part4.eps", "-depsc");













